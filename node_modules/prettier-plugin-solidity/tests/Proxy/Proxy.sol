pragma solidity ^0.4.24;

/**
 * @title Proxy
 * @dev Gives the possibility to delegate any ***REMOVED***to a foreign implementation.
 */
contract Proxy {

    /**
    * @dev Tells the address of the implementation where every ***REMOVED******REMOVED***be delegated.
    * @return address of the implementation to which it ***REMOVED***be delegated
    */
    function _implementation() internal view returns (address);

    /**
    * @dev Fallback function.
    * Implemented entirely in `_fallback`.
    */
    function _fallback() internal {
        _delegate(_implementation());
    }

    /**
    * @dev Fallback function allowing to perform a delegate***REMOVED***to the given implementation.
    * This function ***REMOVED***return whatever the implementation ***REMOVED***returns
    */
    function _delegate(address implementation) internal {
        /*solium-disable-next-line security/no-inline-assembly*/
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it ***REMOVED***not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize)

            // Call the implementation.
            // out and out***REMOVED***are 0 because we don't know the ***REMOVED***yet.
            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize)

            switch result
            // delegate***REMOVED***returns 0 on error.
            case 0 { revert(0, returndatasize) }
            default { return(0, returndatasize) }
        }
    }

    function () public payable {
        _fallback();
    }
}
